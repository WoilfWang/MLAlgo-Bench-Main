Implement the Isomap algorithm for dimensionality reduction with python, numpy and scipy.
Non-linear dimensionality reduction through Isometric Mapping. 

The core idea of Isomap is to maintain the geodesic distances between all pairs of data points when mapping the high-dimensional data to a lower-dimensional space. Geodesic distance is the shortest path between two points on a curved surface, which is more appropriate for data lying on a nonlinear manifold.

### Algorithmic Flow

1. **Construct the Neighborhood Graph:**
   - For each data point, identify its neighbors using either a fixed number of nearest neighbors (k-nearest neighbors) or all points within a certain distance (Îµ-neighborhood).
   - Construct a weighted graph \( G = (V, E) \), where each vertex \( v_i \) represents a data point, and an edge \( e_{ij} \) exists if \( v_j \) is a neighbor of \( v_i \). The weight of the edge is the Euclidean distance between the points.

2. **Compute Geodesic Distances:**
   - Use Dijkstra's or Floyd-Warshall algorithm to compute the shortest paths between all pairs of points in the graph. This approximates the geodesic distances on the manifold.
   - Let \( D_{ij} \) be the geodesic distance between points \( i \) and \( j \).

3. **Apply Classical MDS:**
   - Construct a matrix \( \mathbf{B} \) using double centering:
     \[
     \mathbf{B} = -\frac{1}{2} \mathbf{H} \mathbf{D}^2 \mathbf{H}
     \]
     where \( \mathbf{D}^2 \) is the matrix of squared geodesic distances, and \( \mathbf{H} = \mathbf{I} - \frac{1}{n} \mathbf{1} \mathbf{1}^T \) is the centering matrix.
   - Perform eigenvalue decomposition on \( \mathbf{B} \):
     \[
     \mathbf{B} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^T
     \]
     where \( \mathbf{\Lambda} \) is the diagonal matrix of eigenvalues and \( \mathbf{V} \) is the matrix of eigenvectors.

4. **Dimensionality Reduction:**
   - Select the top \( d \) eigenvectors corresponding to the largest \( d \) eigenvalues to form the reduced-dimensional embedding:
     \[
     \mathbf{Y} = \mathbf{V}_d \mathbf{\Lambda}_d^{1/2}
     \]
     where \( \mathbf{V}_d \) contains the top \( d \) eigenvectors and \( \mathbf{\Lambda}_d \) is the diagonal matrix of the top \( d \) eigenvalues.

The module should be named GPTIsomap.
The init function should include the following parameters:
n_neighbors: Number of neighbors to consider for each point;
n_components: Number of coordinates for the manifold.
The module must contain a fit_transform function, which is used for fitting data and performing dimensionality reduction transformations.
The fit_transform function accepts X as input and return reduced_X where
X: X is the features of the data, which is a numpy array and it's shape is [N, d]. N is the number of the train data and d is the dimension.
reduced_X: reduced_X is the reduced features after dimensionality reduction. The shape should be [N, low_d], where N is the num of the data and low_d is the reduced dimension.
You should just return the code for the module, don't return anything else.